# =============================================================================
# Pipeline DevSecOps - Taskfile.yml
# =============================================================================
# Phases du cycle de vie:
#   1. pre-commit      - Vérifications rapides avant chaque commit
#   2. branch-feature   - Vérifications approfondies sur branche feature
#   3. pull-request     - Validation complète avant merge (CI/CD)
#   4. staging          - Déploiement et validation en pré-production
#   5. production       - Déploiement sécurisé en production
#   6. nightly          - Analyses approfondies planifiées
#
# Usage:
#   task <phase>          - Exécuter une phase complète
#   task <sous-tâche>     - Exécuter une tâche individuelle
#   task --list           - Lister toutes les tâches disponibles
#   task setup            - Installer tous les outils nécessaires
# =============================================================================

version: '3'

dotenv: ['.env']

vars:
  # --- Environnement ---
  CI: '{{.CI | default "false"}}'
  NODE_ENV: '{{.NODE_ENV | default "development"}}'

  # --- Docker ---
  DOCKER_REGISTRY: '{{.DOCKER_REGISTRY | default "localhost:5000"}}'
  IMAGE_NAME: '{{.IMAGE_NAME | default "devsecops-api"}}'
  IMAGE_TAG: '{{.IMAGE_TAG | default "latest"}}'
  DOCKERFILE: '{{.DOCKERFILE | default "Dockerfile"}}'

  # --- SonarQube ---
  SONAR_URL: '{{.SONAR_URL | default "http://localhost:9000"}}'
  SONAR_PROJECT_KEY: '{{.SONAR_PROJECT_KEY | default "demo-devsecops-api-j1"}}'

  # --- Staging / Production ---
  STAGING_URL: '{{.STAGING_URL | default "http://localhost:3001"}}'
  PROD_URL: '{{.PROD_URL | default "http://localhost:3000"}}'
  STAGING_COMPOSE: '{{.STAGING_COMPOSE | default "docker-compose.staging.yml"}}'
  PROD_COMPOSE: '{{.PROD_COMPOSE | default "docker-compose.prod.yml"}}'

  # --- Seuils ---
  COVERAGE_THRESHOLD: '{{.COVERAGE_THRESHOLD | default "60"}}'
  TRIVY_SEVERITY: '{{.TRIVY_SEVERITY | default "HIGH,CRITICAL"}}'

  # --- Rapports ---
  REPORTS_DIR: '{{.REPORTS_DIR | default "reports"}}'

# =============================================================================
# PHASE 1 : PRE-COMMIT
# Vérifications rapides avant chaque commit (~30s)
# =============================================================================

tasks:

  pre-commit:
    desc: "[Phase 1] Vérifications pré-commit (lint, format, secrets, tests unitaires)"
    cmds:
      - task: lint
      - task: format-check
      - task: secrets-scan
      - task: unit-test

  lint:
    desc: "Analyse statique du code avec ESLint"
    cmds:
      - npx eslint src/ --ext .js --format {{if eq .CI "true"}}json{{else}}stylish{{end}} {{if eq .CI "true"}}--output-file {{.REPORTS_DIR}}/eslint-report.json{{end}}
    sources:
      - src/**/*.js

  format-check:
    desc: "Vérification du formatage avec Prettier"
    cmds:
      - npx prettier --check "src/**/*.js"

  secrets-scan:
    desc: "Détection de secrets avec gitleaks"
    preconditions:
      - sh: command -v gitleaks
        msg: "gitleaks n'est pas installé. Lancez 'task setup' ou installez-le : https://github.com/gitleaks/gitleaks"
    cmds:
      - mkdir -p {{.REPORTS_DIR}}
      - gitleaks detect --source . --verbose --redact --report-format json --report-path {{.REPORTS_DIR}}/gitleaks-report.json
    ignore_error: true

  unit-test:
    desc: "Tests unitaires rapides (fail-fast)"
    cmds:
      - npx jest --bail --forceExit --detectOpenHandles {{if eq .CI "true"}}--ci --reporters=default --reporters=jest-junit{{end}}
    env:
      NODE_ENV: test
      JEST_JUNIT_OUTPUT_DIR: "{{.REPORTS_DIR}}"

# =============================================================================
# PHASE 2 : FEATURE BRANCH
# Vérifications approfondies pendant le développement (~2-5min)
# =============================================================================

  branch-feature:
    desc: "[Phase 2] Vérifications sur branche feature (pre-commit + SAST + SCA)"
    cmds:
      - task: pre-commit
      - task: sast
      - task: npm-audit
      - task: license-check
      - task: outdated

  sast:
    desc: "Analyse SAST avec Semgrep (règles OWASP)"
    preconditions:
      - sh: command -v semgrep
        msg: "Semgrep n'est pas installé. Lancez 'task setup' ou: pip install semgrep"
    env:
      PYTHONUTF8: "1"
      PYTHONIOENCODING: utf-8
    cmds:
      - mkdir -p {{.REPORTS_DIR}}
      - semgrep scan --config=auto --config=p/owasp-top-ten --config=p/nodejs --config=p/javascript {{if eq .CI "true"}}--json --output={{.REPORTS_DIR}}/semgrep-report.json{{else}}--verbose{{end}} src/
    ignore_error: true

  npm-audit:
    desc: "Scan des vulnérabilités dans les dépendances (npm audit)"
    cmds:
      - npm audit {{if eq .CI "true"}}--json > {{.REPORTS_DIR}}/npm-audit-report.json || true{{else}}--audit-level=moderate{{end}}

  license-check:
    desc: "Vérification de conformité des licences"
    cmds:
      - npx license-checker --summary --failOn "GPL-3.0;AGPL-3.0;UNLICENSED" {{if eq .CI "true"}}--json > {{.REPORTS_DIR}}/license-report.json{{end}}

  outdated:
    desc: "Détection des dépendances obsolètes"
    cmds:
      - npm outdated || true

# =============================================================================
# PHASE 3 : PULL REQUEST
# Validation complète avant merge (~5-15min)
# =============================================================================

  pull-request:
    desc: "[Phase 3] Validation complète pour Pull Request (CI/CD)"
    cmds:
      - task: branch-feature
      - task: integration-test
      - task: coverage
      - task: sonarqube-scan
      - task: docker-build
      - task: trivy-image
      - task: snyk-test

  integration-test:
    desc: "Tests d'intégration API (Jest + Supertest)"
    cmds:
      - npx jest --testPathPattern="integration|e2e" --forceExit --detectOpenHandles {{if eq .CI "true"}}--ci{{end}}
    env:
      NODE_ENV: test

  coverage:
    desc: "Couverture de code avec seuil minimum ({{.COVERAGE_THRESHOLD}}%)"
    cmds:
      - npx jest --coverage --coverageReporters=text --coverageReporters=lcov --coverageReporters=json-summary --coverageDirectory=coverage --forceExit --detectOpenHandles {{if eq .CI "true"}}--ci{{end}}
      - |
        echo "=== Vérification du seuil de couverture ({{.COVERAGE_THRESHOLD}}%) ==="
        if [ -f coverage/coverage-summary.json ]; then
          ACTUAL=$(node -e "const c=require('./coverage/coverage-summary.json');console.log(Math.round(c.total.lines.pct))")
          echo "Couverture actuelle: ${ACTUAL}%"
          if [ "$ACTUAL" -lt "{{.COVERAGE_THRESHOLD}}" ]; then
            echo "ÉCHEC: Couverture (${ACTUAL}%) inférieure au seuil ({{.COVERAGE_THRESHOLD}}%)"
            exit 1
          fi
          echo "OK: Couverture suffisante"
        else
          echo "ATTENTION: Pas de rapport de couverture généré"
        fi
    env:
      NODE_ENV: test

  sonarqube-scan:
    desc: "Analyse de qualité avec SonarQube"
    preconditions:
      - sh: command -v sonar-scanner
        msg: "sonar-scanner n'est pas installé. Lancez 'task setup' ou: npm i -g sonar-scanner"
    cmds:
      - sonar-scanner -Dsonar.host.url={{.SONAR_URL}} -Dsonar.projectKey={{.SONAR_PROJECT_KEY}} {{if ne .SONAR_TOKEN ""}} -Dsonar.token={{.SONAR_TOKEN}}{{end}}

  docker-build:
    desc: "Build de l'image Docker"
    preconditions:
      - sh: command -v docker
        msg: "Docker n'est pas installé."
    cmds:
      - docker build -t {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}} -f {{.DOCKERFILE}} .
      - echo "Image construite - {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}"

  trivy-image:
    desc: "Scan de vulnérabilités de l'image Docker avec Trivy"
    preconditions:
      - sh: command -v trivy
        msg: "Trivy n'est pas installé. Lancez 'task setup' ou: https://aquasecurity.github.io/trivy"
    cmds:
      - mkdir -p {{.REPORTS_DIR}}
      - trivy image --severity {{.TRIVY_SEVERITY}} --format {{if eq .CI "true"}}json --output {{.REPORTS_DIR}}/trivy-image-report.json{{else}}table{{end}} {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}

  snyk-test:
    desc: "Analyse approfondie des dépendances avec Snyk"
    preconditions:
      - sh: command -v snyk
        msg: "Snyk n'est pas installé. Lancez 'task setup' ou: npm i -g snyk && snyk auth"
    cmds:
      - snyk test {{if eq .CI "true"}}--json > {{.REPORTS_DIR}}/snyk-report.json || true{{else}}--severity-threshold=medium{{end}}

# =============================================================================
# PHASE 4 : STAGING
# Déploiement et validation en pré-production (~10-20min)
# =============================================================================

  staging:
    desc: "[Phase 4] Déploiement et validation en staging"
    cmds:
      - task: docker-build-staging
      - task: docker-push-staging
      - task: deploy-staging
      - task: smoke-test
      - task: dast
      - task: performance-test

  docker-build-staging:
    desc: "Build de l'image Docker pour staging"
    cmds:
      - docker build -t {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:staging -f {{.DOCKERFILE}} --build-arg NODE_ENV=staging .

  docker-push-staging:
    desc: "Push de l'image vers le registry (staging)"
    cmds:
      - docker push {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:staging

  deploy-staging:
    desc: "Déploiement en environnement staging"
    cmds:
      - |
        echo "=== Déploiement en staging ==="
        if [ -f {{.STAGING_COMPOSE}} ]; then
          docker compose -f {{.STAGING_COMPOSE}} pull
          docker compose -f {{.STAGING_COMPOSE}} up -d --force-recreate
          echo "Attente du démarrage des services..."
          sleep 10
        else
          echo "ATTENTION: {{.STAGING_COMPOSE}} non trouvé."
          echo "Déploiement manuel requis ou créez le fichier docker-compose.staging.yml"
          exit 1
        fi

  smoke-test:
    desc: "Tests de fumée sur les endpoints critiques"
    cmds:
      - |
        echo "=== Smoke Tests - {{.STAGING_URL}} ==="
        FAILED=0

        # Health check
        echo -n "Health check... "
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" {{.STAGING_URL}}/api/health 2>/dev/null)
        if [ "$STATUS" = "200" ]; then
          echo "OK ($STATUS)"
        else
          echo "ÉCHEC ($STATUS)"
          FAILED=1
        fi

        # Page d'accueil
        echo -n "Page d'accueil... "
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" {{.STAGING_URL}}/ 2>/dev/null)
        if [ "$STATUS" = "200" ]; then
          echo "OK ($STATUS)"
        else
          echo "ÉCHEC ($STATUS)"
          FAILED=1
        fi

        # Login endpoint (doit répondre, même erreur 4xx)
        echo -n "Login endpoint... "
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST {{.STAGING_URL}}/api/auth/login -H "Content-Type: application/json" -d '{"username":"test","password":"test"}' 2>/dev/null)
        if [ "$STATUS" -ge 200 ] && [ "$STATUS" -lt 500 ]; then
          echo "OK ($STATUS)"
        else
          echo "ÉCHEC ($STATUS)"
          FAILED=1
        fi

        if [ "$FAILED" -eq 1 ]; then
          echo "=== SMOKE TESTS ÉCHOUÉS ==="
          exit 1
        fi
        echo "=== Tous les smoke tests OK ==="

  dast:
    desc: "Scan DAST avec OWASP ZAP (API scan)"
    preconditions:
      - sh: command -v docker
        msg: "Docker est requis pour exécuter OWASP ZAP"
    cmds:
      - mkdir -p {{.REPORTS_DIR}}
      - |
        echo "=== OWASP ZAP - API Scan contre {{.STAGING_URL}} ==="
        docker run --rm --network=host \
          -v $(pwd)/{{.REPORTS_DIR}}:/zap/wrk:rw \
          ghcr.io/zaproxy/zaproxy:stable \
          zap-api-scan.py \
            -t {{.STAGING_URL}}/ \
            -f openapi \
            -r zap-report.html \
            -J zap-report.json \
            -l WARN \
          || echo "ZAP scan terminé (vérifiez le rapport dans {{.REPORTS_DIR}}/)"

  performance-test:
    desc: "Tests de charge avec k6"
    preconditions:
      - sh: command -v k6
        msg: "k6 n'est pas installé. Lancez 'task setup' ou: https://k6.io/docs/getting-started/installation/"
    cmds:
      - |
        echo "=== Tests de performance - {{.STAGING_URL}} ==="
        if [ -f tests/performance/load-test.js ]; then
          k6 run tests/performance/load-test.js --env BASE_URL={{.STAGING_URL}} {{if eq .CI "true"}}--out json={{.REPORTS_DIR}}/k6-report.json{{end}}
        else
          echo "ATTENTION: Fichier de test k6 non trouvé (tests/performance/load-test.js)"
          echo "Exécution d'un test de charge basique..."
          k6 run --vus 10 --duration 30s - <<'SCRIPT'
        import http from 'k6/http';
        import { check, sleep } from 'k6';
        export default function () {
          const res = http.get('{{.STAGING_URL}}/api/health');
          check(res, { 'status 200': (r) => r.status === 200 });
          sleep(1);
        }
        SCRIPT
        fi

# =============================================================================
# PHASE 5 : PRODUCTION
# Déploiement sécurisé en production
# =============================================================================

  production:
    desc: "[Phase 5] Déploiement sécurisé en production"
    cmds:
      - task: docker-build-prod
      - task: docker-push-prod
      - task: deploy-prod
      - task: smoke-test-prod
      - task: tag-release

  docker-build-prod:
    desc: "Build de l'image Docker pour production"
    cmds:
      - |
        VERSION={{.IMAGE_TAG}}
        if [ "$VERSION" = "latest" ]; then
          VERSION=$(git describe --tags --always 2>/dev/null || echo "0.0.0")
        fi
        echo "Build de l'image de production: {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:${VERSION}"
        docker build \
          -t {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:${VERSION} \
          -t {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:latest \
          -f {{.DOCKERFILE}} \
          --build-arg NODE_ENV=production \
          .

  docker-push-prod:
    desc: "Push de l'image vers le registry (production)"
    cmds:
      - |
        VERSION={{.IMAGE_TAG}}
        if [ "$VERSION" = "latest" ]; then
          VERSION=$(git describe --tags --always 2>/dev/null || echo "0.0.0")
        fi
        docker push {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:${VERSION}
        docker push {{.DOCKER_REGISTRY}}/{{.IMAGE_NAME}}:latest

  deploy-prod:
    desc: "Déploiement en production"
    cmds:
      - |
        echo "=== Déploiement en production ==="
        if [ -f {{.PROD_COMPOSE}} ]; then
          docker compose -f {{.PROD_COMPOSE}} pull
          docker compose -f {{.PROD_COMPOSE}} up -d --force-recreate
          echo "Attente du démarrage des services..."
          sleep 15
        else
          echo "ATTENTION: {{.PROD_COMPOSE}} non trouvé."
          echo "Déploiement manuel requis ou créez le fichier docker-compose.prod.yml"
          exit 1
        fi

  smoke-test-prod:
    desc: "Health check post-déploiement en production"
    cmds:
      - |
        echo "=== Smoke Tests Production - {{.PROD_URL}} ==="
        RETRIES=5
        DELAY=5
        for i in $(seq 1 $RETRIES); do
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" {{.PROD_URL}}/api/health 2>/dev/null)
          if [ "$STATUS" = "200" ]; then
            echo "Health check OK (tentative $i)"
            exit 0
          fi
          echo "Tentative $i/$RETRIES échouée (status: $STATUS). Nouvelle tentative dans ${DELAY}s..."
          sleep $DELAY
        done
        echo "ÉCHEC: Le service n'est pas disponible après $RETRIES tentatives"
        exit 1

  tag-release:
    desc: "Tagging de la release Git"
    cmds:
      - |
        VERSION={{.IMAGE_TAG}}
        if [ "$VERSION" = "latest" ]; then
          VERSION=$(date +%Y%m%d-%H%M%S)
        fi
        echo "Création du tag: v${VERSION}"
        git tag -a "v${VERSION}" -m "Release v${VERSION} - $(date -Iseconds)"
        echo "Tag créé. Pour pousser: git push origin v${VERSION}"
